{"version":3,"sources":["webpack:///./client/Admin/containers/GeneralCatalogue/quickSort.js"],"names":["quickSort","arr","property","sequence","judge","index","middle","Date","getTime","partition","left","right","i","j","quick","length"],"mappings":";;;;;;;;;;;;;;;;QA4BgBA,S,GAAAA,S;;AA5BhB;;;;AACA;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBO,SAASA,SAAT,CAAoBC,GAApB,EAAyBC,QAAzB,EAAmCC,QAAnC,EAA6C;;AAElD;AACAF,QAAM,wBAASA,GAAT,CAAN;;AAEA;;;AAGA,MAAMG,QAAQ,SAARA,KAAQ,CAACD,QAAD,EAAWD,QAAX,EAAqBG,KAArB,EAA4BC,MAA5B,EAAuC;AACnD,QAAIH,aAAa,IAAjB,EAAuB;AACrB,aAAO,IAAII,IAAJ,CAAS,wBAAaN,IAAII,KAAJ,CAAb,EAAyBH,QAAzB,CAAT,EAA6CM,OAA7C,KAAyD,IAAID,IAAJ,CAAS,wBAAaN,IAAIK,MAAJ,CAAb,EAA0BJ,QAA1B,CAAT,EAA8CM,OAA9C,EAAhE;AACD,KAFD,MAEO;AACL,aAAO,IAAID,IAAJ,CAAS,wBAAaN,IAAII,KAAJ,CAAb,EAAyBH,QAAzB,CAAT,EAA6CM,OAA7C,KAAyD,IAAID,IAAJ,CAAS,wBAAaN,IAAIK,MAAJ,CAAb,EAA0BJ,QAA1B,CAAT,EAA8CM,OAA9C,EAAhE;AACD;AACF,GAND;;AAQA;;;;;;;AAOA,MAAMC,YAAY,SAAZA,SAAY,CAACC,IAAD,EAAOC,KAAP,EAAiB;;AAEjC;AACA,QAAML,SAAUI,OAAOC,KAAR,IAAkB,CAAjC;AACA;AACA,QAAIC,IAAIF,IAAR;AACA,QAAIG,IAAIF,KAAR;;AAEA;AACA;AACA,WAAOC,KAAKC,CAAZ,EAAe;;AAEb;AACA;AACA,aAAOT,MAAMD,QAAN,EAAgBD,QAAhB,EAA0BU,CAA1B,EAA6BN,MAA7B,CAAP,EAA6C;AAC3C,UAAEM,CAAF;AACD;;AAED;AACA;AACA,aAAOR,MAAM,CAACD,QAAP,EAAiBD,QAAjB,EAA2BW,CAA3B,EAA8BP,MAA9B,CAAP,EAA8C;AAC5C,UAAEO,CAAF;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,UAAID,KAAKC,CAAT,EAAY;AACV,wBAAKZ,GAAL,EAAUW,CAAV,EAAaC,CAAb;AACA,UAAED,CAAF;AACA,UAAEC,CAAF;AACD;AACF;;AAED;AACA,WAAOD,CAAP;AACD,GAvCD;;AAyCA;;;AAGA,MAAME,QAAQ,SAARA,KAAQ,CAACJ,IAAD,EAAOC,KAAP,EAAiB;AAC7B,QAAIL,eAAJ;;AAEA;AACA,QAAIL,IAAIc,MAAJ,GAAa,CAAjB,EAAoB;;AAElB;AACA;AACAT,eAASG,UAAUC,IAAV,EAAgBC,KAAhB,CAAT;;AAEA;AACA,UAAID,OAAOJ,SAAS,CAApB,EAAuB;AACrBQ,cAAMJ,IAAN,EAAYJ,SAAS,CAArB;AACD;;AAED;AACA,UAAIA,SAASK,KAAb,EAAoB;AAClBG,cAAMR,MAAN,EAAcK,KAAd;AACD;AAEF;;AAED,WAAOV,GAAP;AACD,GAvBD;;AAyBA,SAAOa,MAAM,CAAN,EAASb,IAAIc,MAAJ,GAAa,CAAtB,CAAP;AACD;;;;;;;;;;;;0BA7Fef,S","file":"general-catalogue.108e6c81cd14e3d6c8d6.hot-update.js","sourcesContent":["import deepCopy from '../../../lib/deepCopy'\nimport { findProperty, swap } from './sort'\n\n/**\n * 快排\n * // === 1 思想：[a, b, c, d, e], 利用分治发，定c为中间值，然后分别从a和e向c遍历，分别找到左边比c大, 右边比c小的值，比如a,e; 然后交换位置, 依次类推；最后一定是c左边的值比c小，右边的值都比c大；再分别对c左边的值和右边的值用同样的取中间值比较的方式逐层的递归直到划分出来需要比较的系列的长度只有1为止 === //\n * // === 2 最好情况复杂度分析: === //\n *\n * 递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n)\n *\n * 最优的情况就是每一次取到的元素都刚好平分整个数组: T[n] = 2T[n/2] + f(n)\n * T[n/2]为平分后的子数组的时间复杂度\n * f[n] 为平分这个数组时所花的时间\n *\n * T[n] =  2T[n/2] + n         // 第一次递归\n * 令：n = n/2       T[n] =  2 { 2 T[n/4] + (n/2) }  + n    // 第二次递归\n *                        =  2^2 T[ n/ (2^2) ] + 2n\n *  令：n = n/(2^2)  T[n]  =  2^2  {  2 T[n/ (2^3) ]  + n/(2^2)}  +  2n\n *                        =  2^3 T[  n/ (2^3) ]  + 3n   // 第三次递归\n *\n *\n *\n * @param {Array} arr - 数组\n * @param {Boolean} sequence - true为正序，false为倒序\n * @param {Array} property - 排序时比较的属性名\n * @return {Array}\n */\n\nexport function quickSort (arr, property, sequence) {\n\n  // 深拷贝一份数组, 之后的所有操作都对这份数组操作\n  arr = deepCopy(arr)\n\n  /**\n   * 判断函数\n   */\n  const judge = (sequence, property, index, middle) => {\n    if (sequence === true) {\n      return new Date(findProperty(arr[index], property)).getTime() < new Date(findProperty(arr[middle], property)).getTime()\n    } else {\n      return new Date(findProperty(arr[index], property)).getTime() > new Date(findProperty(arr[middle], property)).getTime()\n    }\n  }\n\n  /**\n   * 根据left和right将arr中此范围的数据分为二, 计算出中间的分割值, 左边的比它都小, 右边的比它都打\n   * @param {Number} left - 左边界索引\n   * @param {Number} right - 右边界索引\n   * @return {Number} 中间值索引\n   * @private\n   */\n  const partition = (left, right) => {\n\n    // 计算出给定范围内的中间索引值作为参考标准\n    const middle = (left + right) >> 1\n    // 复制左右边界索引\n    let i = left\n    let j = right\n\n    // 当左边界索引比右边界索引小\n    // 证明还可以比较\n    while (i <= j) {\n\n      // 如果索引i位置的值比middle位置的值小\n      // 下标i继续向middle方向移动\n      while (judge(sequence, property, i, middle)) {\n        ++i\n      }\n\n      // 如果索引j位置的值比middle位置的值大\n      // 下标j继续向middle方向移动\n      while (judge(!sequence, property, j, middle)) {\n        --j\n      }\n\n      // 当上面两个循环有发现不符的\n      // 在此时 下标i所指的位置 和 下标j所指的位置 还没 相越\n      // 证明 下标i所指的值 比middle大, 下标j所指的位置比middle小\n      // 互换位置\n      // 下标 i j 继续向middle移动\n      // 直到 下标i/j 相越则使得 middle左边范围的值 比 middle所指的值小, middle右边范围的值 都比 middle所指的值 大: [left, i) [j, right)\n      if (i <= j) {\n        swap(arr, i, j)\n        ++i\n        --j\n      }\n    }\n\n    // 最后下标i的值为 下标j\n    return i\n  }\n\n  /**\n   * 根据给出的left和right边界, 计算出 middle, 再让 左范围 和 右范围 的数据做同样的二分\n   */\n  const quick = (left, right) => {\n    let middle\n\n    // 当数组长度大于1的时候\n    if (arr.length > 1) {\n\n      // 计算出该数组中间值的索引\n      // 该计算使得该索引值左边的所有元素比它小, 右边的所有元素比它大\n      middle = partition(left, right)\n\n      // 以相同的方式处理 [left, middle) 区间的元素\n      if (left < middle - 1) {\n        quick(left, middle - 1)\n      }\n\n      // 以相同方式处理 [middle, right] 区间的元素\n      if (middle < right) {\n        quick(middle, right)\n      }\n\n    }\n\n    return arr\n  }\n\n  return quick(0, arr.length - 1)\n}"],"sourceRoot":""}