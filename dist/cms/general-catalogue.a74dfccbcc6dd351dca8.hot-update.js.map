{"version":3,"sources":["webpack:///./client/Admin/containers/GeneralCatalogue/sort.js"],"names":["swap","arr","prev","next","findProperty","obj","property","i","len","length","item"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA;;AAEA;AACA;;;AAGA;;;;;;;;AAQO,IAAMA,sBAAO,SAAPA,IAAO,CAACC,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAqB;AACvCF,MAAIE,IAAJ,IAAY,CAACF,IAAIC,IAAJ,CAAD,EAAYD,IAAIC,IAAJ,IAAYD,IAAIE,IAAJ,CAAxB,EAAmC,CAAnC,CAAZ;AACD,CAFM;;AAIP;;;;;;;AAOO,IAAMC,sCAAe,SAAfA,YAAe,CAACC,GAAD,EAAMC,QAAN,EAAmB;AAC7C,MAAIC,IAAI,CAAR;AACA,MAAMC,MAAMF,SAASG,MAArB;;AAEA,MAAI,QAAOJ,GAAP,uDAAOA,GAAP,OAAe,QAAnB,EAA6B;AAC3B,WAAOA,GAAP;AACD;;AAED,SAAOE,IAAIC,GAAX,EAAgB;AACd,QAAIE,OAAOJ,SAASC,CAAT,CAAX;AACA,QAAIF,IAAIK,IAAJ,MAAc,WAAlB,EAA+B;AAAG;AAChCL,YAAMA,IAAIK,IAAJ,CAAN;AACD,KAFD,MAEO;AACL,aAAOL,GAAP;AACD;;AAED,MAAEE,CAAF;AACD;;AAED,SAAOF,GAAP;AACD,CApBM;;;;;;;;;;;;0BAXML,I;0BAWAI,Y","file":"general-catalogue.a74dfccbcc6dd351dca8.hot-update.js","sourcesContent":["// === 技巧: 当把每一个算法学懂了而之后, 再去对比归纳它们之间的异同, 归纳完后想忘记也很难了 === //\n\n// === 复杂度: === //\n// === 1 大O: n表示数据规模, O(f(n))表示运行算法所需执行的指令数, 与f(n)成正比 === //\n// === 1.1 计算: 取指数最大的, 如 n^3 + n^2 + log2n = O(n^3)  === //\n// === 2 时间复杂度: 看平均值, 前三 O(n^2); 中四 O(n * log n); 后二 O(n+ k); 基排 O(O * k) === //\n/*\n  // O(1): 没有数据规模的变化\n  void swapTwoInts (int &a, int &b)\n  {\n    int temp = a;\n    a = b;\n    b = temp;\n  }\n\n  // O(n): 有循环, 且遍历次数与 n 相关\n  int sum (int n)\n  {\n    int ret = 0;\n    for (int i = 0; i <= n; ++i)\n    {\n      ret += i;\n    }\n    return ret;\n  }\n\n  // O(n^2): 双重循环, 每层循环都与 n 相关\n  void selectionSort (int arr[], int n)\n  {\n    for (int i = 0; i < n; ++i)\n    {\n      int minIndex = i;\n      for (int j = i + 1; j < n; ++j)\n      {\n        if (arr[j] < arr[minIndex])\n        {\n          minIndex = j;\n        }\n      }\n      swap(arr[j], arr[minIndex]);\n    }\n  }\n\n  // O(logn):\n  int binarySearch (int arr[], int n, int target)   |\n  {\n    int l = 0, r = n - 1;\n    while (l < r)\n    {\n      int mid = l + (r - l) / 2;\n      if (arr[mid] === target)\n      {\n        return mid;\n      }\n      if (arr[mid] > target)\n      {\n        r = mid - 1;\n      }\n      else\n      {\n        l = mid + 1;\n      }\n    }\n    return -1;\n  }\n\n  思路: 在n个元素中查找 -> 在n/2个元素中查找 -> 在n/4个元素中查找 -> ... -> 在1个元素中查找\n  实质: n 经过几次 \"除以2\" 操作后等于 1 ? -> log2n = O(logn)\n\n*/\n// === 3 空间复杂度: 递归调用有空间代价, 在递归调用前会将函数的状态压入系统调用栈中 === //\n\n// === 稳定性: 关键字相同的记录排序前后的相对位置不发生改变 === //\n// === 1 记忆技巧：一般来说，若存在不相邻元素间交换，则很可能是不稳定的排序 === //\n\n\n/**\n * 交换位置\n * // === 技巧：利用代码执行顺序，后一个赋值为前一个，而前一个赋值为前一个的行为在数组的第二项进行 === //\n * @param {Array} arr - 数组\n * @param {Number} prev - 前一个索引\n * @param {Number} next - 后一个索引\n * @private\n */\nexport const swap = (arr, prev, next) => {\n  arr[next] = [arr[prev], arr[prev] = arr[next]][0]\n}\n\n/**\n * 查找对象属性\n * @param {Object} obj 对象\n * @param {Array} property - 属性为顺序的数组，如：{one: {two: '1'}} 为 ['one', 'two']\n * @private\n * @return {String|Number}\n */\nexport const findProperty = (obj, property) => {\n  let i = 0\n  const len = property.length\n\n  if (typeof obj !== 'object') {\n    return obj\n  }\n\n  while (i < len) {\n    let item = property[i]\n    if (obj[item] !== 'undefined') {  // === 此处，判断一个属性是否存在，不能用隐式转换，因为有可能属性值为0, false, undefined, '', null从而判断错误 === //\n      obj = obj[item]\n    } else {\n      return obj\n    }\n\n    ++i\n  }\n\n  return obj\n}\n"],"sourceRoot":""}