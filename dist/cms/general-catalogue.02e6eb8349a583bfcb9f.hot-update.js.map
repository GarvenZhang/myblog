{"version":3,"sources":["webpack:///./client/Admin/containers/GeneralCatalogue/mergeSort.js"],"names":["mergeSort","merge","left","right","property","sequence","judge","ret","length","push","shift","_mergeSort","arr","l","middle","slice"],"mappings":";;;;;;;;;;;;;;;;QAuEgBA,S,GAAAA,S;;AAvEhB;;;;AACA;;;;;;;;;;AAEA;;;;;;;;;;;;;AAaA,SAASC,KAAT,CAAgBC,IAAhB,EAAsBC,KAAtB,EAA6BC,QAA7B,EAAuCC,QAAvC,EAAiD;;AAE/C;;;AAGA,MAAMC,QAAQ,SAARA,KAAQ,GAAM;AAClB,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,wBAAaH,KAAK,CAAL,CAAb,EAAsBE,QAAtB,IAAkC,wBAAaD,MAAM,CAAN,CAAb,EAAuBC,QAAvB,CAAzC;AACD,KAFD,MAEO;AACL,aAAO,wBAAaF,KAAK,CAAL,CAAb,EAAsBE,QAAtB,IAAkC,wBAAaD,MAAM,CAAN,CAAb,EAAuBC,QAAvB,CAAzC;AACD;AACF,GAND;;AAQA;AACA,MAAIG,MAAM,EAAV;;AAEA;AACA;AACA,SAAOL,KAAKM,MAAL,GAAc,CAAd,IAAmBL,MAAMK,MAAN,GAAe,CAAzC,EAA4C;AAC1C,QAAIF,OAAJ,EAAa;AACXC,UAAIE,IAAJ,CAASP,KAAKQ,KAAL,EAAT;AACD,KAFD,MAEO;AACLH,UAAIE,IAAJ,CAASN,MAAMO,KAAN,EAAT;AACD;AACF;;AAED;AACA,SAAOR,KAAKM,MAAL,GAAc,CAArB,EAAwB;AACtBD,QAAIE,IAAJ,CAASP,KAAKQ,KAAL,EAAT;AACD;AACD,SAAOP,MAAMK,MAAN,GAAe,CAAtB,EAAyB;AACvBD,QAAIE,IAAJ,CAASN,MAAMO,KAAN,EAAT;AACD;;AAED,SAAOH,GAAP;AACD;;AAED;;;AAGA,SAASI,UAAT,CAAqBC,GAArB,EAA0BR,QAA1B,EAAoCC,QAApC,EAA8C;;AAE5C,MAAMQ,IAAID,IAAIJ,MAAd;AACA,MAAIK,MAAM,CAAV,EAAa;AACX,WAAOD,GAAP;AACD;;AAED,MAAME,SAASD,KAAK,CAApB;AACA,MAAIX,OAAOU,IAAIG,KAAJ,CAAU,CAAV,EAAaD,MAAb,CAAX;AACA,MAAIX,QAAQS,IAAIG,KAAJ,CAAUD,MAAV,EAAkBF,IAAIJ,MAAtB,CAAZ;;AAEA,SAAOP,MAAMU,WAAWT,IAAX,EAAiBE,QAAjB,EAA2BC,QAA3B,CAAN,EAA4CM,WAAWR,KAAX,EAAkBC,QAAlB,EAA4BC,QAA5B,CAA5C,EAAmFD,QAAnF,EAA6FC,QAA7F,CAAP;AACD;;AAGM,SAASL,SAAT,CAAoBY,GAApB,EAAyBR,QAAzB,EAAmCC,QAAnC,EAA6C;AAClDO,QAAM,wBAASA,GAAT,CAAN;AACA,SAAOD,WAAWC,GAAX,EAAgBR,QAAhB,EAA0BC,QAA1B,CAAP;AACD;;;;;;;;;;;;0BA1DQJ,K;0BAwCAU,U;0BAeOX,S","file":"general-catalogue.02e6eb8349a583bfcb9f.hot-update.js","sourcesContent":["import deepCopy from '../../../lib/deepCopy'\nimport { findProperty, swap } from './sort'\n\n/**\n * 归并\n * // === 1 思想：[a, b, c, d ,e], 用分治划出左右数组，递归直到长度为1；比如a与b比较，c与d比较，排序后放入新数组返回，之后，cd与e比较，ab与cde比较 === //\n * // === 2 时间复杂度: T[n]  =  2T[n/2] + O(n) === //\n * // === 2.1 数组划分函数: 划分两部分，那每一小部分排序好所花时间则为  T[n/2] === //\n * // === 2.2 有序数组归并函数: 代码中有3个长度为n的循环（非嵌套）, 所以时间复杂度则为O(n) === //\n * // === 2.3  === //\n * @param {Array} arr - 数组\n * @param {Boolean} sequence - true为正序，false为倒序\n * @param {Array} property - 排序时比较的属性名\n * @return {Array}\n */\n\nfunction merge (left, right, property, sequence) {\n\n  /**\n   * 判断函数\n   */\n  const judge = () => {\n    if (sequence === true) {\n      return findProperty(left[0], property) < findProperty(right[0], property)\n    } else {\n      return findProperty(left[0], property) > findProperty(right[0], property)\n    }\n  }\n\n  // 结果数组\n  let ret = []\n\n  // 一开始每两两长度为1的数组中的元素进行顺序比较\n  // 通过判断, 小的先放进 ret, 大的后放进ret\n  while (left.length > 0 && right.length > 0) {\n    if (judge()) {\n      ret.push(left.shift())\n    } else {\n      ret.push(right.shift())\n    }\n  }\n\n  // 若做完以上操作后, left数组 或者 right数组要有剩余的, 证明是比较比ret中的都大, 则直接一个个放进去就好了\n  while (left.length > 0) {\n    ret.push(left.shift())\n  }\n  while (right.length > 0) {\n    ret.push(right.shift())\n  }\n\n  return ret\n}\n\n/**\n * 不断地二分数组, 直到划分为每个数组长度为1为止\n */\nfunction _mergeSort (arr, property, sequence) {\n\n  const l = arr.length\n  if (l === 1) {\n    return arr\n  }\n\n  const middle = l >> 1\n  let left = arr.slice(0, middle)\n  let right = arr.slice(middle, arr.length)\n\n  return merge(_mergeSort(left, property, sequence), _mergeSort(right, property, sequence), property, sequence)\n}\n\n\nexport function mergeSort (arr, property, sequence) {\n  arr = deepCopy(arr)\n  return _mergeSort(arr, property, sequence)\n}\n"],"sourceRoot":""}