# 用jwt实现sso

关于sso, 我搞了好久, 从一开始的一无所知, 到不断采坑, 思路换了一种又一种, 甚是刻苦铭心!

## 一.常用的会话管理方式

### 1.1 基于server-session

1 服务器有个sessions对象, `sessions = {}}`

2 用户第一次访问, 根据真实IP加密生成一个随机key(`fjfelkjafklwjxxxx`), 不可逆的, `sessions = { fjfelkjafklwjxxxx: {} }`,
然后把 sessionid 注入到 cookie 中

3 用户登录, 账号密码发给服务器后, 验证成功, 从数据库中取出必要的会话信息(如id, name等), 放到 `sessions['fjfelkjafklwjxxxx']` 中, 并设定过期时间, 如2h。

4 用户请求授权信息时, 服务器从cookie中拿着 sessionid , 从 `sessions` 中查找会话信息。

若在过期时间内, 继续执行接下来的操作, 并延长 2h 的session过期时间

若过期了, 删除 `sessions['fjfelkjafklwjxxxx']` 对象, 创建新的 session 对象, 如`sessions['fjeowiajfkel22']`， 将用户重定向到登录界面

5 用户主动退出: 直接删除 `sessions['fjfelkjafklwjxxxx']` 对象

**缺点**:

1 会话信息存在服务器中, 用户同时在线量较多时占用大量内存

2 当应用采用 集群部署时, 有可能创建session的服务器 并非 处理用户请求的服务器

3 多个应用共享 session 时, 会遇到跨域问题

4 对于在过期时间内, 没有主动退出的情况, session 一直在内存中

5 csrf安全问题

**解决方案**:

1 使用redis中间服务器管理 session 的增删查改, 及共享session问题

2 对于跨域问题, 需前后端实现 cookie 跨域访问(`ACCESS-CONTROL-ALLOW-ORIGIN` + `withCredentials`)

3 开个定时器, 扫描 sessions , 对于过期的直接删除以释放内存

### 1.2 基于cookie-based

`server-session`方式会增加服务器负担, 而`cookie-baesd`则是把 登录凭证 直接放到 客户端cookie , 达到服务器无状态化

1 用户登录, 后端验证账号密码后, 从数据库中取出必要信息(如id, name)等, 加上创建时间和过期时间, 写成对象形式`{id: 1, name: 'garven', createdTime: '2343298923', max-age: '8288'}`,
通过 JSON.stringify() 转成字符串做为一个 登录凭证, 然后做 数字签名 ,再用对称加密算法做加密处理, 再写入 cookie , 如`ticket: xxxx`

做签名目的: 防止登录凭证被篡改, 篡改后无法 签名验证 成功

做加密目的: 防止被窃取后读到其中的用户信息

2 用户请求授权信息: 拿到cookie中的 ticket 对应的值, 解密和签名认证后, 得到登录凭证, 再验证是否过期; 没过期则继续操作, 过期则删除cookie, 重定向到登录页

**缺点**:

1 cookie大小限制: 影响其他需要用到cookie的业务

2 每次传送带着cookie, 增大了报文的数据量

3 跨域问题

4 csrf问题

5 native app 不好管理 cookie, 毕竟不是浏览器

**解决办法**:

1 如可以考虑从一开始的 4096位 RSA算法做数字签名时 换成 1024、2048等

### 1.3 基于token-based

将 `cookie-based` 中的 ticket 换成 token 名, token 返回给客户端后, 后续的每个请求都必须通过 url 或者 http header 方式 主动带上 token, 服务器接收到后直接从 http header 或者 url 里拿到 token

1 存储: localStorage 或者 sessionStorage 里

2 方便跨域请求

3 刷新问题: 在验证 token 有效之后, 会把 token 的失效时间延长, 再返回给客户端; 客户端如果检测到服务器有新的 token , 则替换

---

## 二.CAS(Central Authentication Service)

实现SSO单点登录的框架

### 2.1 CAS协议过程

![sso-1.webp](sso-1.webp)

访问服务： SSO 客户端发送请求访问应用系统提供的服务资源。

定向认证： SSO 客户端会重定向用户请求到 SSO 服务器。

用户认证：用户身份认证。

发放票据： SSO 服务器会产生一个随机的 Service Ticket 。

验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。

传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。

### 2.2 信息登录传递

**用户首次登录**:

![sso-4.webp](sso-4.webp)

1 用户浏览器访问系统A需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据

2 系统A发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，没有，进行登录

3 认证中心呈现登录页面，用户登录，登录成功后，认证中心重定向请求到系统A，并附上认证通过令牌，此时认证中心同时生成了全局票据

4 此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统A与认证中心通信，验证令牌有效,证明用户已登录

5 系统A将受限资源返给用户

**已登录的用户首次访问应用群中的系统B**:

![sso-3.webp](sso-3.webp)

1 浏览器访问另一应用B需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据

2 系统B发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，获取全局票据，可以获得，认证中心发现已经登录

3 认证中心发放临时票据(令牌)，并携带该令牌重定向到系统B

4 此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统B与认证中心通信，验证令牌有效,证明用户已登录

5 系统B将受限资源返回给客户端

### 2.3 登录状态判断

1 全局会话: 户到认证中心登录后，用户和认证中心之间建立起的会话

2 局部会话: 系统应用和用户浏览器之间建立的会话，局部会话依附于全局会话存在，全局会话消失，局部会话必须消失

用户访问应用时，首先判断局部会话是否存在，如存在，即认为是登录状态，无需再到认证中心去判断。如不存在，就重定向到认证中心判断全局会话是否存在，如存在，按1提到的方式通知该应用，该应用与客户端就建立起它们之间局部会话，下次请求该应用，就不去认证中心验证了

### 2.4 登出

认证中心接到登出通知，即可结束全局会话，同时需要通知所有已建立局部会话的子系统，将它们的局部会话销毁。这样，用户访问其它应用时，都显示已登出状态

**登出流程**:

1 客户端向应用A发送登出Logout请求

2 应用A取消本地会话，同时通知认证中心，用户已登出

3 应用A返回客户端登出请求

4 认证中心通知所有用户登录访问的应用，用户已登出

### 2.5 疑问:

1 系统A是如何发现该请求需要登录重定向到认证中心的?

用户通过浏览器地址栏访问系统A，系统A(也可以称为CAS客户端)去Cookie中拿 `JSESSION`，即在Cookie中维护的当前回话session的id，如果拿到了，说明用户已经登录，如果未拿到，说明用户未登录

2 系统A重定向到认证中心，发送了什么信息或者地址变成了什么?

假如系统A的地址为http://a:8080/，CAS认证中心的服务地址为http://cas.server:8080/，那么重点向前后地址变化为：http://a:8080/————>ttp://cas.server:8080/?service=http://a:8080/，由此可知，重定向到认证中心，认证中心拿到了当前访问客户端的地址

3 登录成功后，认证中心重定向请求到系统A，认证通过令牌是如何附加发送给系统A的?

重定向之后的地址栏变成：http://a:8080/?ticket=ST-XXXX-XXX，将票据以ticket为参数名的方式通过地址栏发送给系统A

4 系统A验证令牌，怎样操作证明用户登录的?

系统A通过地址栏获取ticket的参数值ST票据，然后从后台将ST发送给CAS server认证中心验证，验证ST有效后，CAS server返回当前用户登录的相关信息，系统A接收到返回的用户信息，并为该用户创建session会话，会话id由cookie维护，来证明其已登录

5 登录B系统，认证中心是如何判断用户已经登录的?

在系统A登录成功后，用户和认证中心之间建立起了全局会话，这个全局会话就是TGT(Ticket Granting Ticket)，TGT位于CAS服务器端，TGT并没有放在Session中，也就是说，CAS全局会话的实现并没有直接使用Session机制，而是利用了Cookie自己实现的，这个Cookie叫做TGC(Ticket Granting Cookie)，它存放了TGT的id,保存在用户浏览器上。

用户发送登录系统B的请求，首先会去Cookie中拿JSESSION，因为系统B并未登录过，session会话还未创建，JSESSION的值是拿不到的，然后将请求重定向到CAS认证中心，CAS认证中心先去用户浏览器中拿TGC的值，也就是全局会话id，如果存在则代表用户在认证中心已经登录，附带上认证令牌重定向到系统B

6 登出的过程，各个系统对当前用户都做了什么?

认证中心清除当前用户的全局会话TGT，同时清掉cookie中TGT的id：TGC；然后是各个客户端系统，比如系统A、系统B，清除局部会话session，同时清掉cookie中session会话id：jsession

---

## 三.JWT实现SSO

**第一次访问的是系统 A 的 some/page**:












































